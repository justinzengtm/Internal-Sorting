#include <stdio.h>
#include <stdlib.h>
#define MaxSize 20
typedef int ElemType;

//待排记录的存储结构
typedef struct SqlList *PtrlSqlList;
struct SqlList{
	ElemType arr[MaxSize+1]; //r[0]做为哨兵
	int length; //顺序表的长度
}; //顺序表类型

//函数声明
void Insert_Array(PtrlSqlList P, int K); //序列插入元素
void Insertion_Sort(PtrlSqlList P, int N); //插入排序
void PrintList(PtrlSqlList P); //输出序列
int GetListLength(PtrlSqlList P); //计算序列的长度

int main(int argc, char const* argv[]) 
{
	int data=0;
	PtrlSqlList P;
	P=(PtrlSqlList)malloc(sizeof(struct SqlList));
	P->arr[1]=-1;
	P->arr[0]=0;
	
	printf("\n请创建序列:");
	while (data!=-1) {
		scanf("%d", &data);
		Insert_Array(P, data);
	} 
	
	printf("\n原序列为:");
	PrintList(P);
	//获得序列长度
	P->length=GetListLength(P);
	printf("\n序列长度为 = %d\n", P->length);
	//插入排序
	Insertion_Sort(P, P->length);
	//输出序列
	printf("\n直接插入排序后:");
	PrintList(P); 
	
	return 0;
}

//序列插入元素
void Insert_Array(PtrlSqlList P, int K)
{
	int i=1;
	while (P->arr[i]!=-1) {
		i++;
	}
	P->arr[i]=K;
	P->arr[i+1]=-1;
}

//输出序列
void PrintList(PtrlSqlList P) 
{
	int i=1; 
	while (P->arr[i]!=-1) {
		printf("%d\t", P->arr[i]);
		i++;
	}
} 

//直接插入排序
void Insertion_Sort(PtrlSqlList P, int N) 
{
	int i, j, Tmp, flag;
	printf("\n直接插入排序过程:\n");
	for (i=2; i<=N; i++) {
		Tmp=P->arr[i]; /*从序列中逐个拿出元素*/
		printf("Tmp=%d\n", Tmp);
		for (j=i; j>1 && P->arr[j-1]>Tmp; j--) {
			P->arr[j]=P->arr[j-1]; /*往后挪一位*/
		}
		P->arr[j]=Tmp; //最后找到比Tmp大的数都往后挪了,留下正确的位置就插入
		PrintList(P); //此为输出序列函数,此处每次输出一次排序后的序列
		printf("\n");
	}
} 

//计算序列的长度
int GetListLength(PtrlSqlList P) 
{
	int i=1;
	while (P->arr[i]!=-1) {
		i++;
	}

	return (i-1);
}
